#include <Arduino.h>
#include "Astraea.h"
#include "Agility.h"
#include "AD9959.h"
#include "Hardware.h"
#include <SPI.h>
#include "ADC.h"
#include <LittleFS.h>

#include "Errors.h"
#include "Serial.h"
#include <SerialBuffer.h>
#include <TimerOne.h>
#include <EEPROM.h>

// Astraea data structure
//
// Two DDS channels are used to generate the two QUAD output signals, phase 1 and phase 2. The
// main channel is used to generate the PWM signals based on the defined modulus and counting. 
// Generally, there will be an error that is corrected using the phase offsets generated by the 
// modulation DDS channel.
//
// Phase 1’s falling edge and phase 2’s rising edge are always coincident. The DDS modulation 
// channel toggles between two different phase offsets controlled by a window around the falling 
// edge phase 1. The modulation channel’s base phase offset is the phase 1 error between the PWM 
// signal and the desired duty cycle. Sense phase 1’s falling edge and phase 2’s rising edge are 
// coincident then the phase 1 correction phase offset will shorten phase 2’s width. The actual 
// phase 2 correction is the sum of the required phase 2 correction plus the phase 1 offset.
//
// These phase offset are calculated and written to the DDS modulation channels registers.
//
// Note; Trigger outputs and inputs use inverting buffers!

// FPGA design to dos:
//  - Change registers module into system configuration
//      - 4 leds for status
//      - 4 bits to control behavior
//          - load on PWM0 zerocount
//          - load on PWM1 zerocount
//          - DDSupdate on load
//          - load config without load strobe
//  - Update the scan module to allow selection of the PWM module
//  - Update the scan mould to generate an interrupt num waveforms after a trigger, this
//    is needed for the agility capability
//
//
// To support agility we need the following
//  - Set up for 4 wire SPI?
//  - SPI at 10MHz, 32 bit transfer in 3.2uS
//  - State update needs:
//      - Frequency, 5 bytes
//      - Phase1, 3 bytes
//      - Phase2, 5 bytes but this may work with only 3, need to test
//      - PWM parameters, 4 bytes
//      - Total of 15 bytes best case, 120 bits, 12uS. at 500KHz this is 6 waveforms
//      - Could go at 20MHz and reduce to 3 waveforms.
//      - 4 bit SPI would get us to 2 waveforms
//  - Need to develop a state structure that holds system state values
//    in format ready for download
//

// mz = cVT^2
// cV = constant
// T = sqrt(mz/cV) 
//
// mz = ((9.775e6)Vo-p)/(q ro^2 F^2)
// F = sqrt(((9.775e6)Vo-p)/(q ro^2 mz))
// F = sqrt(((9.775e6)Vo-p)/(q ro^2)) * sqrt(1/mz)
// F = c * sqrt(1/mz), c = sqrt(((9.775e6)Vo-p)/(q ro^2))
//
// t1 = duty cycle for phase 1 in percent, from it we calculate t3 to filter mode and
//      t3 = 0. t3 = 100 - t1, t2 = 0
// t3 = duty cycle for phase 2 in percent, also sets t2. t2 = 100 - t1 - t3
//
// Version history
//  1.0 march 5, 2023
//    - Initial releae
//  1.1 April 6, 2023
//    - Added QUAD Driver support
//    - Fixed a sync phase shift issue between 1st and 2nd QUAD
//  1.2 April 6, 2023
//    - Fixed bug in driver that made scanning fail. Can't update the QUAD driver when scanning!
//    - Need to exit update function when scanning
//  1.3 April 29, 2023
//    - Added agility functions
//  1.4 June 14, 2023
//    - Rewrote the agility function to properly support scanning.
//    - Expanded the PWM range to 5 to 95%
//  1.5 July 29, 2023
//    - Fixed a bug in the scanning routing, was not lateching the scan data into the FPGA
//    - The new 5 and 95% limit were not applied to agility funtions
//    - Added commands to enable sending the T2 pulse to Trig2
//  1.6 Sept 6, 2023
//    - Add command to set or pulse trig1 and trig2
//    - Add command to read the trigger input signal
//  1.7 Feb 23, 2024
//    - Fixed scan bug in quad2, the PWM parameter was not set in the FPGA
//  1.8 June 4, 2024
//    - Added command to alow inverting the edge use to trigger scan stepping
//  1.9 July 9, 2024
//    - Fixed a bug in the sync mode when the quad parameters were different
//    - Configure now processes changes in Vop, Ro and Q
//    - Updated the FPGA code and the firmware to fix a timing issue when the quads
//      are in sync mode
//  1.10 Aug 1, 2024
//    - Fixed a bug that was introduced in rev 1.9, the sync mode was not propery cleard.
//    - Also fixed an issue with the FPGA due to a file not getting updated resulting
//      in the t2 pulse not being generated.
//
// To do:
//    - Add external trigger option to start agility table
//    - Update the scan function to allow agility table execution at each step in
//      the scan
//    - Allow agility table to select quad channel

const char   Version[] PROGMEM = "Astraea version 1.10, Aug 1, 2024";
ASTRAEA      astraea;

LittleFS_Program myfs;
File systemData;

int eeAddress = 0;

SerialBuffer sb;

// ThreadController that will control all threads
ThreadController control = ThreadController();
//Threads
Thread SystemThread = Thread();

ASTRAEA Rev_1_astraea = {
    sizeof(ASTRAEA),"Astraea",1,
    // FPGA system control
    {14,4},
    // DQUAD parameters
    false,
    {{
       40,
       20,60,
       false,
       100,5.0,1,         // Vop, ro, q
       100000.0,          // Frequuency
       2000.0,            // m/z
       40.0,0.0,60.0,     // t1,t2,t3
       // DDS parameters
       Channel0,
       Channel1,
       10000000.0,
       0,0,
       { 0, 0x0F, 40, 17, 20 },
    },
    {
       40,
       20,60,
       false,
       100,5.0,1,         // Vop, ro, q
       100000.0,          // Frequuency
       2000.0,            // m/z
       40.0,0.0,60.0,     // t1,t2,t3
       // DDS parameters
       Channel2,
       Channel3,
       10000000.0,
       0,0,
       { 4, 0x0F, 40, 17, 18 },
    }},
    // SCAN parameters
    0,
    SCAN_MZ,
    { 8, 0, 3, 100},   
    // QUAD driver parameters
    false,false,0,0,
    {0,0},
    {0,0},
    {{VP1ADC,516.21,19.48},   {VP2ADC,515.50,-13.30}},
    {{VN1ADC,514.37,64257.06},{VN2ADC,513.51,64257.78}},
    {{VP1DAC,512.91,15.78},   {VP2DAC,513.51,11.77}},
    {{VN1DAC,-512.01,-0.46},  {VN2DAC,-525.27,-9.36}},
    0,
    {},
    "a",
    SIGNATURE
};

DDS    *dds;
ADC    *adc     = new ADC();
double ddsClock = 500000000.0;
int    MaxFreq  = 25000000;

bool   T3_enable[2] = {false,false};

// Scan parameters
float         scnStart    = 200;
float         scnStop     = 10000;
int           scanSteps   = 5000;
int           wfmsPerStep = 50;
double        scnCurrent  = scnStart;
double        scnStep     = 1;
volatile bool acquired;
int           ADCcount;
int           ADCsum;
bool          generateScanTrig = false;
bool          waitForScanTrig = false;
bool          waitForScanTrigNeg = false;
bool          scanADVtrig = false;

State sdata;
float VPrb[2] = {-1,-1};
float VNrb[2] = {-1,-1};

// Init the AD5592 (Analog and digital IO chip) for the Astraea module.
void AD5592init(int8_t addr)
{
   pinMode(addr,OUTPUT);
   digitalWrite(addr,HIGH);
   SPI.beginTransaction(SPISettings(SPISLOWCLK, MSBFIRST, SPI_MODE2));
   // General purpose configuration
   AD5592write(addr, 3, 0x0100);
   // Set internal reference
   AD5592write(addr, 11, 0x0200);
   // Set LDAC mode
   AD5592write(addr, 7, 0x0000);
   // Set DO outputs channels
   AD5592write(addr, 8, 0x0000);
   // Set DAC outputs channels
   AD5592write(addr, 5, 0x0095);
   // Set ADC input channels
   AD5592write(addr, 4, 0x006A);
   // Turn off all pulldowns
   AD5592write(addr, 6, 0x0000);
   
   // Set default values
   // Init DAC channels to mid range
   AD5592writeDAC(addr, 0, 0);
   AD5592writeDAC(addr, 2, 0);
   AD5592writeDAC(addr, 4, 0);
   AD5592writeDAC(addr, 7, 0);
   SPI.endTransaction();
   SPI.beginTransaction(SPISettings(SPIFASTCLK, MSBFIRST, SPI_MODE0));
}

double mz2freq(double mz, DQUAD *quad)
{
  double Ro = quad->ro/1000.0;
  double c = sqrt(((9.775e6) * quad->Vop)/(quad->q * Ro * Ro));
  return(c * sqrt(1.0/mz));
}

double mz2freq(DQUAD *quad)
{
  quad->freq = mz2freq(quad->mz,quad);
  quad->DDSfreq = quad->freq * quad->modulus;
  return(quad->freq);  
}

double freq2mz(double freq, DQUAD *quad)
{
  double Ro = quad->ro/1000.0;
  return((9.775e6)*quad->Vop)/(quad->q * Ro * Ro * freq * freq);
}

double freq2mz(DQUAD *quad)
{
  quad->mz = freq2mz(quad->freq,quad);
  quad->DDSfreq = quad->freq * quad->modulus;
  return(quad->mz);
}

// This function will evaluate the modulus value passed and return
// the sum of the t1 and t2 duty cycle errors in ppm. The quad data
// structure is updated if the updateStruct flag is true
float configureModulus(int mod, DQUAD *quad, bool updateStruct = false)
{
  // Evaluate t1
  double txdcc = quad->t1 / 100.0 * mod * PHASEOFFSETRANGE;  
  int txdps    = txdcc / PHASEOFFSETRANGE;
  int txps     = txdcc - (double)txdps * (double)PHASEOFFSETRANGE + 0.5;
  if(txps >= PHASEOFFSETRANGE) {txps -= PHASEOFFSETRANGE; txdps++;}
  if((txps > 0) && (txps < PHASEMARGIN)) txps = 0;
  int t1ps = txps;
  float ppm = abs((((txdps * PHASEOFFSETRANGE + txps) - txdcc) / txdcc) * 1000000.0);
  if(updateStruct)
  {
    // Set the FPGA parameters
    quad->PWM.mod = mod;
    quad->PWM.pwmp1 = txdps;
    // Set DDS parameters
    quad->DDSoffset1 = txps;
    // Adjust the config modulation bits
    quad->PWM.cfg &= ~((1 << P1M) | (1 << P2M));
    if(txps > 0) quad->PWM.cfg |= (1 << P1M);
  }
  // Evaluate t3
  txdcc = quad->t3 / 100.0 * mod * PHASEOFFSETRANGE;  
  txdps = txdcc / PHASEOFFSETRANGE;
  txps  = txdcc - (double)txdps * (double)PHASEOFFSETRANGE + 0.5;
  if(txps >= PHASEOFFSETRANGE) {txps -= PHASEOFFSETRANGE; txdps++;}
  if((txps + t1ps) > PHASEOFFSETRANGE) if((PHASEOFFSETRANGE - (txps + t1ps)) < PHASEMARGIN) txps -= PHASEMARGIN;
  if(txps < PHASEMARGIN) txps = 0;
  ppm += abs((((txdps * PHASEOFFSETRANGE + txps) - txdcc) / txdcc) * 1000000.0);
  txps += t1ps;
  if(txps >= PHASEOFFSETRANGE) {txps -= PHASEOFFSETRANGE; txdps++;}
  if(updateStruct)
  {
    // Set the FPGA parameters
    quad->PWM.pwmp2 = txdps;
    // Set DDS parameters
    quad->DDSoffset2 = txps;
    // Adjust the config bits
    if(txps > 0) quad->PWM.cfg |= (1 << P2M);
  }
  return ppm;
}

int findModulus(double freq, DQUAD *quad)
{
  int   UL = quad->maxMod;
  int   LL = quad->minMod;
  int   bestMod;
  float ppm;
  
  if(quad->fixedMod) return quad->modulus;
  if(UL > MaxFreq/freq) UL = MaxFreq/freq;
  if(LL > UL) return UL;
  ppm = configureModulus(UL, quad);
  bestMod = UL;
  for(int i = LL; i<=UL; i++)
  {
    if(configureModulus(i, quad) <= ppm)
    {
      ppm = configureModulus(i, quad);
      bestMod = i;
    }
  }
  return bestMod;
}

void configQUAD(DQUAD *quad)
{
  // If we are in the sync mode for both channels then:
  // - Set the sync bit in PWM1 FPGA config byte
  // - Set all DDS channel with frequency
  // - Use this channels modulus for both channels
  astraea.quads[0].PWM.cfg &= ~(1 << SYNCN);
  astraea.quads[0].PWM.cfg &= ~(1 << SYNCP);
  if(astraea.syncQuads)
  {
    dds->begin();
    astraea.quads[0].PWM.cfg |= (1 << SYNCN);
    astraea.quads[0].modulus = astraea.quads[1].modulus = findModulus(quad->freq, quad);
    astraea.quads[0].freq = astraea.quads[1].freq = quad->freq;
    //astraea.quads[0].mz = astraea.quads[1].mz = quad->mz;
    freq2mz(&astraea.quads[0]);
    freq2mz(&astraea.quads[1]);

    configureModulus(quad->modulus, &astraea.quads[0],true);
    configureModulus(quad->modulus, &astraea.quads[1],true);
    astraea.quads[0].DDSfreq = astraea.quads[1].DDSfreq = quad->freq * quad->modulus;
    // Set DDS parameters
    dds->setFrequency(ChannelAll,quad->DDSfreq);
    for(int i = 0; i < 2; i++)
    {
      dds->setPhase(astraea.quads[i].DDSmodChannel,PHASEOFFSETRANGE - astraea.quads[i].DDSoffset1);
      if(astraea.quads[i].DDSoffset2 == 0) dds->write(0x0A, 0);
      else dds->write(0x0A, (PHASEOFFSETRANGE - astraea.quads[i].DDSoffset2) << 18);
      if((astraea.quads[i].DDSoffset1 + astraea.quads[i].DDSoffset2) > 0) dds->enableModulation(astraea.quads[i].DDSmodChannel, true);
      else dds->enableModulation(astraea.quads[i].DDSmodChannel, false);
    }
    // Set FPGA registers
    SYSTEMupdate(&astraea.sysCtrl);
    PWMupdate(&astraea.quads[0].PWM);
    PWMupdate(&astraea.quads[1].PWM);
    // Latch the data
    Pulse(LOAD);
    dds->update();
    Pulse(RST);
    return;
  }
  quad->modulus = findModulus(quad->freq, quad);
  configureModulus(quad->modulus, quad,true);
  quad->DDSfreq = quad->freq * quad->modulus;
  // Set DDS parameters
  dds->setFrequency((ChannelNum)(quad->DDSchannel | quad->DDSmodChannel),quad->DDSfreq);
  dds->setPhase(quad->DDSmodChannel,PHASEOFFSETRANGE - quad->DDSoffset1);
  if(quad->DDSoffset2 == 0) dds->write(0x0A, 0);
  else dds->write(0x0A, (PHASEOFFSETRANGE - quad->DDSoffset2) << 18);
  if((quad->DDSoffset1 + quad->DDSoffset2) > 0) dds->enableModulation(quad->DDSmodChannel, true);
  else dds->enableModulation(quad->DDSmodChannel, false);
  // Set FPGA registers
  SYSTEMupdate(&astraea.sysCtrl);
//  PWMupdate(&quad->PWM);
  PWMupdate(&astraea.quads[0].PWM);
  PWMupdate(&astraea.quads[1].PWM);
  // Latch the data
  Pulse(LOAD);
  dds->update();
  Pulse(RST);
}

void scanAdvISR(void)
{
  scanADVtrig = true;
}

void ScanISR(void)
{
 // Exit if no scan in progress return
  if(digitalRead(SIP) == LOW) return;
  astraea.scan.cfg &= ~(1 << ScanAdv);      // Clear advance bit
  writeCFG(&astraea.scan);
  // While the interrupt pin is high read and sum the ADC value and count the number of readings
  adc->adc0->analogReadContinuous();
  ADCsum = ADCcount = 0;
  while(digitalRead(INTRP) == HIGH)
  {
    ADCsum += adc->adc0->analogReadContinuous();
    ADCcount++;
  }
  // Flag indicating the event has been processed
  acquired = true;
}

void initAD9959(void)
{
  // Init the IO ports
  pinMode(SDIO_3,OUTPUT);     // SD3
  digitalWrite(SDIO_3,LOW);

  pinMode(UPDATEDDS,OUTPUT);
  digitalWrite(UPDATEDDS,LOW);
  
  pinMode(P0,INPUT);     // P0
  //digitalWrite(P0,LOW);
  pinMode(P1,INPUT);     // P1
  //digitalWrite(P1,LOW);
  pinMode(P2,INPUT);     // P2
  //digitalWrite(P2,LOW);
  pinMode(P3,INPUT);     // P3
  //digitalWrite(P3,LOW);

  pinMode(PDC,OUTPUT);   // PDC
  digitalWrite(PDC,LOW);

  dds = new DDS();
  dds->begin();
}

void initFPGA(void)
{
  pinMode(SIP,INPUT);
  pinMode(SCS,OUTPUT);
  digitalWrite(SCS,HIGH);
  pinMode(LOAD,OUTPUT);
  digitalWrite(LOAD,LOW);
  pinMode(RST,OUTPUT);
  digitalWrite(RST,HIGH);
}

void SYSTEMupdate(SystemCtrl *sys)
{
  digitalWrite(SCS,LOW);
  SPI.transfer(sys->addr);
  SPI.transfer(sys->cfg);
  //SPI.endTransaction();
  digitalWrite(SCS,HIGH);
}

void PWMupdate(PWMchannel *pwmch)
{
  digitalWrite(SCS,LOW);
  SPI.transfer(pwmch->addr);
  SPI.transfer(pwmch->cfg);
  SPI.transfer(pwmch->mod);
  SPI.transfer(pwmch->pwmp1);
  SPI.transfer(pwmch->pwmp2);
  //SPI.endTransaction();
  digitalWrite(SCS,HIGH);
}

void SCANupdate(SCAN *scan)
{
  digitalWrite(SCS,LOW);
  SPI.transfer(scan->addr);
  SPI.transfer(scan->cfg);
  SPI.transfer(scan->WFperPoint & 0xFF);
  SPI.transfer((scan->WFperPoint>>8) & 0xFF);
  SPI.transfer(scan->NumPoints & 0xFF);
  SPI.transfer((scan->NumPoints>>8) & 0xFF);
  SPI.transfer((scan->NumPoints>>16) & 0xFF);
  //SPI.endTransaction();
  digitalWrite(SCS,HIGH);
}

void writeCFG(SCAN *scan)
{
  digitalWrite(SCS,LOW);
  SPI.transfer(scan->addr);
  SPI.transfer(scan->cfg);
  //SPI.endTransaction();
  digitalWrite(SCS,HIGH);
}

int16_t adc_read(uint8_t mux)
{
  return adc->adc0->analogRead(mux);
}

void ADCinit(void)
{
  adc->adc0->setAveraging(1); // set number of averages
  adc->adc0->setResolution(12); // set bits of resolution
  adc->adc0->setConversionSpeed(ADC_CONVERSION_SPEED::VERY_HIGH_SPEED); // change the conversion speed
  adc->adc0->setSamplingSpeed(ADC_SAMPLING_SPEED::VERY_HIGH_SPEED); // change the sampling speed
  adc->adc0->startContinuous(0);
}

bool UpdateADCvalue(uint8_t SPIcs, ADCchan *achan, float *value, float filter)
{
  int   val;
  float fval;

  if((achan->Chan & 0x80) != 0)
  {
    // Here if this is a M0 ADC pin
    val = 0;
    for(int i=0;i<64;i++) 
    {
      val += analogRead(achan->Chan & 0x7F);
      delayMicroseconds(1);
    }
    val /= 4;
    //val = analogRead(achan->Chan & 0x7F) << 4;
    fval = Counts2Value(val,achan);
    if(*value == -1) *value = fval;
    else *value = filter * fval + (1 - filter) * *value;
    return true;    
  }
  if((val = AD5592readADC(SPIcs, achan->Chan),10) != -1)
  {
    fval = Counts2Value(val,achan);
    if(*value == -1) *value = fval;
    else *value = filter * fval + (1 - filter) * *value;
    return true;
  }
  return false;
}

bool UpdateDACvalue(uint8_t SPIcs, DACchan *dchan, float *value, float *svalue)
{
  if((sdata.update) || (*value != *svalue))
  {
    AD5592writeDAC(SPIcs, dchan->Chan, Value2Counts(*value,dchan));
    *svalue = *value;
    return true;
  }
  return false;
}

void Update()
{
  static bool LastEnableState = false;

  if(digitalRead(SIP) == HIGH) return;
  if(!astraea.DriverPresent) return;
  if(executing) return;
  SPI.beginTransaction(SPISettings(SPISLOWCLK, MSBFIRST, SPI_MODE2));
  for(int i = 0;i < 2; i++)
  {
    UpdateADCvalue(VCS, &astraea.VOPMon[i], &VPrb[i]); 
    UpdateADCvalue(VCS, &astraea.VONMon[i], &VNrb[i]); 


    if(astraea.Venable) VENABLE;
    else VDISABLE;
//    if(astraea.Venable)
    {
//      VENABLE;
      if(!LastEnableState) sdata.update=true;
      if((sdata.update) || (astraea.VP[i] != sdata.VP[i]))
      {
        AD5592writeDAC(VCS, astraea.VOPCtrl[i].Chan, Value2Counts(astraea.VP[i],&astraea.VOPCtrl[i]));
        sdata.VP[i] = astraea.VP[i];
      }
      if((sdata.update) || (astraea.VN[i] != sdata.VN[i]))
      {
        AD5592writeDAC(VCS, astraea.VONCtrl[i].Chan, Value2Counts(astraea.VN[i],&astraea.VONCtrl[i]));
        sdata.VN[i] = astraea.VN[i];
      }
    }
//    else
//    {
//      VDISABLE;
//      AD5592writeDAC(VCS, astraea.VOPCtrl[i].Chan, Value2Counts(0,&astraea.VOPCtrl[i]));
//      AD5592writeDAC(VCS, astraea.VONCtrl[i].Chan, Value2Counts(0,&astraea.VONCtrl[i]));    
//    }
  }
  LastEnableState = astraea.Venable;
  sdata.update = false;
  SPI.endTransaction();
  SPI.beginTransaction(SPISettings(SPIFASTCLK, MSBFIRST, SPI_MODE0));
}

void setup() 
{
  pinMode(VENA,OUTPUT);
  VDISABLE;
  pinMode(Trig1,OUTPUT);
  digitalWrite(Trig1,HIGH);
  pinMode(Trig2,OUTPUT);
  digitalWrite(Trig2,HIGH);
  delay(1000);

  myfs.begin(0x1024 * 64);

  // Read the flash config contents and test the signature
  astraea = Rev_1_astraea;
  Restore();
  
  // Init serial communications
  SerialInit();
  SPI.begin();
  SPISettings(SPIFASTCLK, MSBFIRST, SPI_MODE0);
  // Init the hardware
  initFPGA();
  initAD9959();
  // Turn on all DDS channels and set tp 100KHz
  dds->setFrequency(ChannelAll,5000000);
  dds->setPhase(ChannelAll,0);
  dds->setAmplitude(ChannelAll,1023);
//dds->shutdown(ChannelAll, true);
  dds->update();
  Pulse(LOAD);
  Pulse(RST);
  // Configure Threads
  SystemThread.setName((char *)"Update");
  SystemThread.onRun(Update);
  SystemThread.setInterval(100);
  // Add thread to the controller
  control.add(&SystemThread);
  ADCinit();
  // Initalize QUAD driver if present
  pinMode(VCS,OUTPUT);
  digitalWrite(VCS,HIGH);
  if(astraea.DriverPresent)
  {
    AD5592init(VCS);
  }
  sdata.update = true;
}

void ReadAllSerial(void)
{
  // Put serial received characters in the input ring buffer
  if (Serial.available() > 0)
  {
    serial = &Serial;
    PutCh(Serial.read());
  }
}

// This function process all the serial IO and commands
void ProcessSerial(bool scan)
{
  // Put serial received characters in the input ring buffer
  if (Serial1.available() > 0)
  {
    serial = &Serial1;
    PutCh(Serial1.read());
  }
  // Put serial received characters in the input ring buffer
  if (Serial.available() > 0)
  {
    serial = &Serial;
    PutCh(Serial.read());
  }
  if (!scan) return;
  // If there is a command in the input ring buffer, process it!
  if (RB_Commands(&RB) > 0) while (ProcessCommand() == 0); // Process until flag that there is nothing to do
}

void loop() 
{
  static int cnt=0;
  static uint32_t now;
  char     ch;

  ProcessSerial();
  control.run();

  if(executing) 
  {
    // Here if the states table is executing
    return;
  }
  scanADVtrig = false;
  if(digitalRead(SIP) == HIGH)
  {
    // Wait for trigger if enabled
    if(waitForScanTrig) while(!scanADVtrig) 
    {
      ProcessSerial();
      if(digitalRead(SIP) == LOW) break;
    }
    scanADVtrig = false;
    astraea.scan.cfg |= (1 << ScanAdv);      // Set advance bit
    writeCFG(&astraea.scan);
    while(acquired == false) if(digitalRead(SIP) == LOW) break;
    // Set next set parameters
    noInterrupts();
    if(astraea.scanTyp == SCAN_FREQ)
    {
       astraea.quads[astraea.scanCh].freq = scnCurrent + scnStep;
       freq2mz(&astraea.quads[astraea.scanCh]);
       dds->setFrequency((ChannelNum)(astraea.quads[astraea.scanCh].DDSchannel | astraea.quads[astraea.scanCh].DDSmodChannel),astraea.quads[astraea.scanCh].DDSfreq);     
       if(astraea.syncQuads)
       {
          astraea.quads[astraea.scanCh ^ 1].freq = scnCurrent + scnStep;
          freq2mz(&astraea.quads[astraea.scanCh ^ 1]);
          dds->setFrequency((ChannelNum)(astraea.quads[astraea.scanCh ^ 1].DDSchannel | astraea.quads[astraea.scanCh ^ 1].DDSmodChannel),astraea.quads[astraea.scanCh ^ 1].DDSfreq);             
       }
    }
    if(astraea.scanTyp == SCAN_MZ)
    {
       astraea.quads[astraea.scanCh].mz = scnCurrent + scnStep;
       mz2freq(&astraea.quads[astraea.scanCh]);
       dds->setFrequency((ChannelNum)(astraea.quads[astraea.scanCh].DDSchannel | astraea.quads[astraea.scanCh].DDSmodChannel),astraea.quads[astraea.scanCh].DDSfreq);     
       if(astraea.syncQuads)
       {
          astraea.quads[astraea.scanCh ^ 1].mz = scnCurrent + scnStep;
          mz2freq(&astraea.quads[astraea.scanCh ^ 1]);
          dds->setFrequency((ChannelNum)(astraea.quads[astraea.scanCh ^ 1].DDSchannel | astraea.quads[astraea.scanCh ^ 1].DDSmodChannel),astraea.quads[astraea.scanCh ^ 1].DDSfreq);     
       }
    }
    if(astraea.scanTyp == SCAN_T1)
    {
       astraea.quads[astraea.scanCh].t1 = scnCurrent + scnStep;
       configQUAD(&astraea.quads[astraea.scanCh]);
    }
    if(astraea.scanTyp == SCAN_T3) 
    {
       astraea.quads[astraea.scanCh].t3 = scnCurrent + scnStep;
       configQUAD(&astraea.quads[astraea.scanCh]);
    }
    interrupts();
    dds->update();
    // Report results
    serial->print(1 + cnt++);
    serial->print(",");
    serial->print(scnCurrent,3);
    serial->print(",");
    serial->println((float)ADCsum/(float)ADCcount,3);
    //serial->println(ADCcount);
    serial->flush();
    // If generateScanTrig is set then generate a 1uS pulse on
    // Trig1 output
    if(generateScanTrig)
    {
      digitalWrite(Trig1,LOW);
      delayMicroseconds(1);
      digitalWrite(Trig1,HIGH);
    }
    // Wait for a reply from the host before advancing 
    now = millis();
    while(true)
    {
      if(serial->available() > 0)
      {
        ch = serial->read();
        if(ch == 'n') break;
        else PutCh(ch);
      }
      if((millis() - now) > SCANTIMEOUT)
      {
        // We timed out so abort the scan
        ScanAbort(false);
        break;
      }
    }
    // Advance to next point
    scnCurrent += scnStep;
    acquired = false;
  }
  else cnt = 0;
}

// Host commands

void SaveSettings(void)
{
  astraea.Signature = SIGNATURE;
  myfs.remove("config");
  systemData = myfs.open("config", FILE_WRITE);
  systemData.write(&astraea, sizeof(ASTRAEA));
  systemData.close();
  //EEPROM.put(eeAddress, astraea);
  SendACK;
}

bool Restore(void)
{
  static ASTRAEA ast;

ast.Signature = 0;
  systemData = myfs.open("config", FILE_READ);
  systemData.read(&ast, sizeof(ASTRAEA));
  systemData.close();



  // Read the flash config contents and test the signature
//  EEPROM.get(eeAddress, ast);
  //serial->println(ast.Signature,HEX);
  if(ast.Signature == SIGNATURE) 
  {
    astraea = ast;
    return true;
  }
  return false;
}

void RestoreSettings(void)
{
  if(Restore()) 
  {
    SendACK; 
  }
  else
  {
    SetErrorCode(ERR_EEPROMWRITE);
    SendNAK;
    return;
  }
}

void FormatFLASH(void)
{
  myfs.quickFormat();
//  EEPROM.put(eeAddress, Rev_1_astraea);  
  SendACK;
}

void SaveCal(void)
{
  myfs.remove("cal");
  systemData = myfs.open("cal", FILE_WRITE);
  if((systemData = myfs.open("cal", FILE_WRITE))==0) serial->println("Can't create cal.dat!");
  else
  {
    size_t num = systemData.write((void *)&astraea.VOPMon[0],sizeof(ADCchan));
    num += systemData.write((void *)&astraea.VOPMon[1],sizeof(ADCchan));
    num += systemData.write((void *)&astraea.VONMon[0],sizeof(ADCchan));
    num += systemData.write((void *)&astraea.VONMon[1],sizeof(ADCchan));
    num += systemData.write((void *)&astraea.VOPCtrl[0],sizeof(DACchan));
    num += systemData.write((void *)&astraea.VOPCtrl[1],sizeof(DACchan));
    num += systemData.write((void *)&astraea.VONCtrl[0],sizeof(DACchan));
    num += systemData.write((void *)&astraea.VONCtrl[1],sizeof(DACchan));
    systemData.close();
    serial->print("cal.dat written, number of bytes = ");
    serial->println((int)num);
  }
}

void LoadCal(void)
{

}

int checkChannel(int ch)
{
  if((ch<1)||(ch>2)) 
  {
    SetErrorCode(ERR_BADARG); 
    SendNAK;
    return -1;
  }
  return ch-1;
}

int checkChannel(char *ch)
{
  int    i;

  sscanf(ch,"%d",&i);
  if((i<1)||(i>2)) 
  {
    SetErrorCode(ERR_BADARG); 
    SendNAK;
    return -1;
  }
  return i-1;
}

bool setVariable(double *v,char *value, double LL, double UL)
{
  double d;

  sscanf(value,"%lf",&d);
  if((d<LL)||(d>UL)) 
  {
    SetErrorCode(ERR_BADARG); 
    SendNAK;
    return false;
  }
  SendACK;
  *v = d;
  return true;
}

bool setVariable(float *v,char *value, float LL, float UL)
{
  float d;

  sscanf(value,"%f",&d);
  if((d<LL)||(d>UL)) 
  {
    SetErrorCode(ERR_BADARG); 
    SendNAK;
    return false;
  }
  SendACK;
  *v = d;
  return true;
}

bool setVariable(int *v,char *value, int LL, int UL)
{
  int d;

  sscanf(value,"%d",&d);
  if((d<LL)||(d>UL)) 
  {
    SetErrorCode(ERR_BADARG); 
    SendNAK;
    return false;
  }
  SendACK;
  *v = d;
  return true;
}

void SetMod(char *ch, char *value) {int i; if((i = checkChannel(ch)) == -1) return; setVariable(&astraea.quads[i].modulus,value,MINMOD,MAXMOD);}
void GetMod(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].modulus);}
void SetMinMod(char *ch, char *value) {int i; if((i = checkChannel(ch)) == -1) return; setVariable(&astraea.quads[i].minMod,value,MINMOD,MAXMOD);}
void GetMinMod(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].minMod);}
void SetMaxMod(char *ch, char *value) {int i; if((i = checkChannel(ch)) == -1) return; setVariable(&astraea.quads[i].maxMod,value,MINMOD,MAXMOD);}
void GetMaxMod(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].maxMod);}

void SetV(char *ch, char *value) {int i; if((i = checkChannel(ch)) == -1) return; setVariable(&astraea.quads[i].Vop,value,MINVOP,MAXVOP);}
void GetV(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].Vop,3);}
void SetRo(char *ch, char *value) {int i; if((i = checkChannel(ch)) == -1) return; setVariable(&astraea.quads[i].ro,value,MINRO,MAXRO);}
void GetRo(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].ro,3);}
void SetQ(char *ch, char *value) {int i; if((i = checkChannel(ch)) == -1) return; setVariable(&astraea.quads[i].q,value,MINQ,MAXQ);}
void GetQ(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].q,3);}
void SetT1(char *ch, char *value) 
{
  int i; 
  
  if((i = checkChannel(ch)) == -1) return; 
  if(setVariable(&astraea.quads[i].t1,value,MINT,MAXT)==false) return;
  astraea.quads[i].t2 = 0;
  astraea.quads[i].t3 = 100.0 - astraea.quads[i].t1;
}
void GetT1(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].t1,3);}
void GetT2(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].t2,3);}
void SetT3(char *ch, char *value)
{
  int i; 
  
  if((i = checkChannel(ch)) == -1) return; 
  if(setVariable(&astraea.quads[i].t3,value,MINT,MAXT)==false) return;
  astraea.quads[i].t2 = 100.0 - astraea.quads[i].t1 - astraea.quads[i].t3;
}
void GetT3(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].t3,3);}

void SetFreq(char *ch, char *value)
{
  int i; 
  
  if((i = checkChannel(ch)) == -1) return; 
  if(setVariable(&astraea.quads[i].freq,value,MINFREQ,MAXFREQ)==false) return;
  freq2mz(&astraea.quads[i]);
  configQUAD(&astraea.quads[i]);
  //astraea.quads[i].DDSfreq = astraea.quads[i].freq * astraea.quads[i].modulus;
  //dds->setFrequency((ChannelNum)(astraea.quads[i].DDSchannel | astraea.quads[i].DDSmodChannel),astraea.quads[i].DDSfreq);
  //dds->update();
}
void GetFreq(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].freq,3);}
void mzSet(char *ch, char *value)
{
  int i; 
  
  if((i = checkChannel(ch)) == -1) return; 
  if(setVariable(&astraea.quads[i].mz,value,freq2mz(MAXFREQ,&astraea.quads[i]),freq2mz(MINFREQ,&astraea.quads[i]))==false) return;
  mz2freq(&astraea.quads[i]);
  configQUAD(&astraea.quads[i]);
  //astraea.quads[i].DDSfreq = astraea.quads[i].freq * astraea.quads[i].modulus;
  //dds->setFrequency((ChannelNum)(astraea.quads[i].DDSchannel | astraea.quads[i].DDSmodChannel),astraea.quads[i].DDSfreq);
  //dds->update();
}
void mzGet(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].mz,3);}

void Get_t1dps(int ch) {if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].PWM.pwmp1);}
void Get_t1ps(int ch)  {if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].DDSoffset1);}
void Get_t3dps(int ch) {if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].PWM.pwmp2);}
void Get_t3ps(int ch)  {if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.quads[checkChannel(ch)].DDSoffset2);}

void readADC(void)
{
  int16_t val = adc->adc0->analogReadContinuous();
  SendACKonly;
  if(!SerialMute) serial->println(val);
}

void SetConfigure(int ch)
{
  if(checkChannel(ch) == -1) return;
  SendACK;
  freq2mz(&astraea.quads[checkChannel(ch)]);
  configQUAD(&astraea.quads[checkChannel(ch)]);
}

// Read/Write a DDS register, reg = base 16, value = base 16
// reg bit 7 = 1 for read, 0x80
void rwDDSreg(char *reg, char *value)
{
  int r,v;
  
  sscanf(reg,"%x",&r);
  sscanf(value,"%x",&v);
  SendACKonly;
  if(!SerialMute) serial->println(dds->write(r, v),HEX);
}

// Sets the config byte in data struture and updates the FPGA
// value is hex
// Config reg names: SYS,SCAN,PWM1,PWM2
void SetCFG(char *reg, char *value)
{
  String Reg;
  int    cfg;

  Reg = reg;
  sscanf(value,"%x",&cfg); 
  if(Reg == "SYS")       {astraea.sysCtrl.cfg = cfg; SYSTEMupdate(&astraea.sysCtrl);}
  else if(Reg == "SCAN") {astraea.scan.cfg = cfg; SCANupdate(&astraea.scan);}
  else if(Reg == "PWM1") {astraea.quads[0].PWM.cfg = cfg; PWMupdate(&astraea.quads[0].PWM);}
  else if(Reg == "PWM2") {astraea.quads[1].PWM.cfg = cfg; PWMupdate(&astraea.quads[1].PWM);}
  else BADARG;
  SendACK;
}

void GetCFG(char *reg)
{
  String Reg;
  int    cfg=-1;

  Reg = reg;
  if(Reg == "SYS")       cfg = astraea.sysCtrl.cfg;
  else if(Reg == "SCAN") cfg = astraea.scan.cfg;
  else if(Reg == "PWM1") cfg = astraea.quads[0].PWM.cfg;
  else if(Reg == "PWM2") cfg = astraea.quads[1].PWM.cfg;
  else BADARG;
  SendACKonly;
  if(!SerialMute) serial->println(cfg, HEX);
}

void phaseSet(char *chan, char *phase)
{
  String token;
  int    ps;

  token = phase;
  ps = token.toInt();
  token = chan;
  if(token == "ALL") dds->setPhase(ChannelAll, ps);
  else if(token == "0") dds->setPhase(Channel0, ps);
  else if(token == "1") dds->setPhase(Channel1, ps);
  else if(token == "2") dds->setPhase(Channel2, ps);
  else if(token == "3") dds->setPhase(Channel3, ps);
  else BADARG;
  dds->update();
  SendACK;
}

void aline(void)
{
  dds->setPhase(ChannelAll, 0);
  dds->update();
  Pulse(RST); 
  SendACK; 
}

void SetLoad(void)   {Pulse(LOAD); SendACKonly;}
void SetUpdate(void) {dds->update(); SendACKonly;}

void writeDrvDAC(int chan, int value)
{
  AD5592writeDAC(VCS, chan, value);
  SendACK;
}

void readDrvADC(int chan)
{
  SendACKonly;
  if(!SerialMute) serial->println(AD5592readADC(VCS, chan, 10));
}

void setScanType(char *scanT) 
{
  String ST = scanT;

  if(ST == "FREQ")    astraea.scanTyp = SCAN_FREQ;
  else if(ST == "MZ") astraea.scanTyp = SCAN_MZ;
  else if(ST == "T1") astraea.scanTyp = SCAN_T1;
  else if(ST == "T3") astraea.scanTyp = SCAN_T3;
  else BADARG;
  SendACK;
}

void getScanType(void) 
{
  SendACKonly;
  if(SerialMute) return;
  if(astraea.scanTyp == SCAN_FREQ) serial->println("FREQ");
  if(astraea.scanTyp == SCAN_MZ)   serial->println("MZ");
  if(astraea.scanTyp == SCAN_T1)   serial->println("T1");
  if(astraea.scanTyp == SCAN_T3)   serial->println("T3");
}

void setScanCh(int ch) {if(checkChannel(ch) == -1) return; SendACK; astraea.scanCh = checkChannel(ch);}
void getScanCh(void) {SendACKonly; if(!SerialMute) serial->println(astraea.scanCh + 1);}

void Scan(void)
{
  // Clear any currect scan in progress
  astraea.scan.cfg = (1 << ScanAbrt);       // Set abort bit
  writeCFG(&astraea.scan);
  delay(1);
  astraea.scan.cfg = 0;                     // Reset abort bit
  writeCFG(&astraea.scan);
  delay(10);
  if(waitForScanTrig) 
  {
    if(waitForScanTrigNeg) attachInterrupt(TrigIn, scanAdvISR,FALLING);
    else  attachInterrupt(TrigIn, scanAdvISR,RISING);
  }
  if(astraea.scanTyp == SCAN_FREQ)
  {
    // Configure system for the highest frequency
    if(scnStart > scnStop) astraea.quads[astraea.scanCh].freq = scnStart;
    else astraea.quads[astraea.scanCh].freq = scnStop;
    freq2mz(&astraea.quads[astraea.scanCh]);
  }
  if(astraea.scanTyp == SCAN_MZ)
  {
    // Configure system for the highest frequency, i.e lowest m/z
    if(scnStart > scnStop) astraea.quads[astraea.scanCh].mz = scnStop;
    else astraea.quads[astraea.scanCh].mz = scnStart;
    mz2freq(&astraea.quads[astraea.scanCh]);    
  }
  configQUAD(&astraea.quads[astraea.scanCh]);
  acquired = false;
  // Setup the ISR to process updates
  attachInterrupt(digitalPinToInterrupt(INTRP), ScanISR, RISING);
  // Configure FPGA with the scan parameters
  astraea.scan.WFperPoint = wfmsPerStep;
  astraea.scan.NumPoints = scanSteps;
  SCANupdate(&astraea.scan);
  Pulse(LOAD);
  // Set starting scan point
  scnStep = (scnStop - scnStart) / (double) scanSteps;
  if(astraea.scanTyp == SCAN_FREQ)
  {
     astraea.quads[astraea.scanCh].freq = scnStart;
     freq2mz(&astraea.quads[astraea.scanCh]);
     dds->setFrequency((ChannelNum)(astraea.quads[astraea.scanCh].DDSchannel | astraea.quads[astraea.scanCh].DDSmodChannel),astraea.quads[astraea.scanCh].DDSfreq);     
  }
  if(astraea.scanTyp == SCAN_MZ)
  {
     astraea.quads[astraea.scanCh].mz = scnStart;
     mz2freq(&astraea.quads[astraea.scanCh]);
     dds->setFrequency((ChannelNum)(astraea.quads[astraea.scanCh].DDSchannel | astraea.quads[astraea.scanCh].DDSmodChannel),astraea.quads[astraea.scanCh].DDSfreq);     
  }
  if(astraea.scanTyp == SCAN_T1)
  {
    astraea.quads[astraea.scanCh].t1 = scnStart;
    configQUAD(&astraea.quads[astraea.scanCh]);
  }
  if(astraea.scanTyp == SCAN_T3)
  {
    astraea.quads[astraea.scanCh].t3 = scnStart;
    configQUAD(&astraea.quads[astraea.scanCh]);
  }
  dds->update();
  scnCurrent = scnStart;
  // Set scan request flag and wait for SIP then lower the scan request.
  // Timeout and exit if this does not happen within 500mS.
  astraea.scan.cfg |= (1 << ScanReq);
  astraea.scan.cfg |= ((astraea.scanCh&1) << ScanChan);  // Added 2/23/24
  writeCFG(&astraea.scan);
  for(int i=0;i<100;i++)
  {
    if(digitalRead(SIP) == HIGH)
    {
      // Here when scanning
      //serial->println("Scanning....");
      astraea.scan.cfg &= ~(1 << ScanReq);
      writeCFG(&astraea.scan);
      SendACK;
      return;
    }
    delay(5);
  }
  SetErrorCode(ERR_TIMEOUT); 
  SendNAK;
}

void ScanAbort(bool report)
{
  if(digitalRead(SIP) == LOW)
  {
    SendACK;
    return;
  }
  astraea.scan.cfg |= (1 << ScanAbrt);      // Set abort bit
  writeCFG(&astraea.scan);
  for(int i=0;i<100;i++)
  {
    if(digitalRead(SIP) == LOW)
    {
      astraea.scan.cfg &= ~(1 << ScanAbrt);  // Clear abort bit
      writeCFG(&astraea.scan);
      if(report) SendACK;
      return;
    }
  }
  if(report) BADARG;
}

// QUAD Driver DC commands
void setVOP(char *val)
{
  String v    = val;
  float  fval = v.toFloat();
  if((fval < 0) || (fval > 100)) BADARG;
  astraea.VOP  = fval;
  astraea.VRES = 0;
  astraea.VP[0] = astraea.VP[1] =  fval;
  astraea.VN[0] = astraea.VN[1] = -fval;
  SendACK;
}

void setVRES(char *val)
{
  String v    = val;
  float  fval = v.toFloat();
  if((fval < 0) || (fval > 10)) BADARG;
  astraea.VRES = fval;

  astraea.VP[0] =  astraea.VOP + fval;
  astraea.VN[0] = -astraea.VOP + fval;
  
  astraea.VP[1] =  astraea.VOP - fval;
  astraea.VN[1] = -astraea.VOP - fval;
  SendACK;
}

void setVP(char *ch, char *val) {int i; if((i = checkChannel(ch)) == -1) return; setVariable(&astraea.VP[i],val,0,120);}
void getVP(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.VP[checkChannel(ch)]);}
void setVN(char *ch, char *val)  {int i; if((i = checkChannel(ch)) == -1) return; setVariable(&astraea.VN[i],val,-120,0);}
void getVN(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(astraea.VN[checkChannel(ch)]);}
void getVPA(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(VPrb[checkChannel(ch)]);}
void getVNA(int ch) { if(checkChannel(ch) == -1) return; SendACKonly; if(!SerialMute) serial->println(VNrb[checkChannel(ch)]);}

void setT2enable(char *ch, char *val)
{
  int    i;
  String Token;

  if((i = checkChannel(ch)) == -1) return;
  Token = val;
  if(Token == "TRUE")
  {
    // Set Trig2 pin to input
    pinMode(Trig2,INPUT_PULLUP);
    // Send enable T3 enable to FPGA
    astraea.sysCtrl.cfg |= 1 << i;
  }
  else if(Token == "FALSE")
  {
    // Set Trig2 pin to output
    pinMode(Trig2,OUTPUT);
    digitalWrite(Trig2,HIGH);
    // Send enable T3 disable to FPGA
    astraea.sysCtrl.cfg &= ~(1 << i);
  }
  else BADARG;
  // Set the system config byte to FPGA
  SYSTEMupdate(&astraea.sysCtrl);
  Pulse(LOAD);
  SendACK;
}

void getT2enable(int ch)
{
  if(checkChannel(ch) == -1) return; SendACKonly; if(SerialMute) return;
  if(astraea.sysCtrl.cfg & (1 << checkChannel(ch))) serial->println("TRUE");
  else serial->println("FALSE");
}

// Trigger commands
void SetTrig(char *ch, char *cmd)
{
  int    chan;
  String ST = ch;
  chan = ST.toInt();
  if((chan < 1) || (chan > 2)) BADARG;
  if(chan == 1) chan = Trig1;
  else chan = Trig2;
  ST = cmd;
  if(ST == "HIGH") digitalWrite(chan,LOW);
  else if(ST == "LOW") digitalWrite(chan,HIGH);
  else if(ST == "PULSE")
  {
    digitalWrite(chan,LOW);
    delayMicroseconds(1);
    digitalWrite(chan,HIGH);
  }
  else BADARG;
  SendACK;
}

void ReadTrigIn(void)
{
  SendACKonly;
  if(digitalRead(TrigIn) == LOW) serial->println("HIGH");
  else serial->println("LOW");
}

void Debug(int Mode)
{
  return;

  dds->setFrequency(ChannelAll,Mode);
  dds->update();
  return;

  serial->println(sizeof(ASTRAEA));
  if(!myfs.begin(0x1024 * 64))
  {
    serial->println("Error setting up disk!");
  }
  myfs.quickFormat();
  Serial.printf("Bytes Used: %llu, Bytes Total:%llu\n", myfs.usedSize(), myfs.totalSize());

}
